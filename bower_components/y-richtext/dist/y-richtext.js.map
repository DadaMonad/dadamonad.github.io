{"version":3,"sources":["../yjs/node_modules/browser-pack/_prelude.js","src/Richtext.js","y-richtext.js"],"names":["e","t","n","r","s","o","u","a","require","i","f","Error","code","l","exports","call","length",1,"module","_classCallCheck","instance","Constructor","TypeError","_possibleConstructorReturn","self","ReferenceError","_inherits","subClass","superClass","prototype","Object","create","constructor","value","enumerable","writable","configurable","setPrototypeOf","__proto__","extend","Y","requestModules","then","YRichtext","_Y$Array$class","os","_model","idArray","valArray","this","_this","getPrototypeOf","_length","instances","v","observe","events","event","type","_createClass","key","map","join","createNewOp","attrs","name","op","attributes","insert","ops","Array","push","pos","content","curPos","selection","_get","split","curSel","endPos","delStart","delEnd","rightSel","undefined","from","to","attrName","attrValue","step2i","step2sel","antiAttrs","_v","deletes","_v2","j","del","performStep4","sel","quill","mutualExcluse","token","setContents","toOTOps","on","delta","console","log","select","retain","afterRetain","diff","enters","formatText","insertText","position","insertSel","index","newSel","selectionStart","selectionEnd","k","delLength","deleteText","x","editor","checkUpdate","regeneratorRuntime","mark","_changed","_args","arguments","wrap","_context","prev","next","forEach","delegateYield","apply","stop","get","utils","CustomType","class","struct","initType","YTextInitializer","model","_context2","Struct","List","c","JSON","stringify","id","t0","abrupt","defineProperties","target","props","descriptor","defineProperty","protoProps","staticProps","object","property","receiver","Function","desc","getOwnPropertyDescriptor","parent","getter"],"mappings":"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","file":"y-richtext.js","sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})","/* global Y */\n'use strict'\n\nfunction extend (Y) {\n  Y.requestModules(['Array']).then(function () {\n    class YRichtext extends Y.Array['class'] {\n      constructor (os, _model, idArray, valArray) {\n        super(os, _model, idArray, valArray)\n        this._length = 0\n        this.instances = []\n        for (var i = 0, v = valArray[i]; i < valArray.length; i++) {\n          if (typeof v === 'string') {\n            this._length++\n          }\n        }\n        var self = this\n        this.observe(function (events) {\n          for (var i = 0, event = events[i]; i < events.length; i++) {\n            if (event.type === 'insert') {\n              if (typeof event.value === 'string') {\n                self._length++\n              }\n            } else if (event.type === 'delete') {\n              if (typeof event.value === 'string') {\n                self._length--\n              }\n            }\n          }\n        })\n      }\n      get length () {\n        return this._length\n      }\n      toString () {\n        return this.valArray.map(function (v) {\n          if (typeof v === 'string') {\n            return v\n          }\n        }).join('')\n      }\n      toOTOps () {\n        var ops = []\n        var op = {\n          insert: [],\n          attributes: {}\n        }\n        function createNewOp () {\n          var attrs = {}\n          // copy attributes\n          for (var name in op.attributes) {\n            attrs[name] = op.attributes[name]\n          }\n          op = {\n            insert: [],\n            attributes: attrs\n          }\n        }\n        var i = 0\n        for (; i < this.valArray.length; i++) {\n          let v = this.valArray[i]\n          if (v.constructor === Array) {\n            if (op.insert.length > 0) {\n              op.insert = op.insert.join('')\n              ops.push(op)\n              createNewOp()\n            }\n            if (v[1] === null) {\n              delete op.attributes[v[0]]\n            } else {\n              op.attributes[v[0]] = v[1]\n            }\n          } else {\n            op.insert.push(v)\n          }\n        }\n        if (op.insert.length > 0) {\n          op.insert = op.insert.join('')\n          ops.push(op)\n        }\n        return ops\n      }\n      insert (pos, content) {\n        var curPos = 0\n        var selection = {}\n        for (var i = 0; i < this.valArray.length; i++) {\n          if (curPos === pos) {\n            break\n          }\n          var v = this.valArray[i]\n          if (typeof v === 'string') {\n            curPos++\n          } else if (v.constructor === Array) {\n            if (v[1] === null) {\n              delete selection[v[0]]\n            } else {\n              selection[v[0]] = v[1]\n            }\n          }\n        }\n        super.insert(i, content.split(''))\n        return selection\n      }\n      delete (pos, length) {\n        /*\n          let x = to be deleted string\n          let s = some string\n          let * = some selection\n          E.g.\n          sss*s***x*xxxxx***xx*x**ss*s\n               |---delete-range--|\n             delStart         delEnd\n          \n          We'll check the following\n          * is it possible to delete some of the selections?\n            1. a dominating selection to the right could be the same as the selection (curSel) to delStart\n            2. a selections could be overwritten by another selection to the right \n        */\n        var curPos = 0\n        var curSel = {}\n        var endPos = pos + length\n        if (length <= 0) return\n        var delStart // relative to valArray \n        var delEnd // ..\n        var v // helper variable for elements of valArray\n\n        for (delStart = 0, v = this.valArray[delStart];  curPos < pos && delStart < this.valArray.length; v = this.valArray[++delStart]) {\n          if (typeof v === 'string') {\n            curPos++\n          } else if (v.constructor === Array) {\n            curSel[v[0]] = v[1]\n          }\n        }\n        for (delEnd = delStart, v = this.valArray[delEnd]; curPos < endPos && delEnd < this.valArray.length; v = this.valArray[++delEnd]) {\n          if (typeof v === 'string') {\n            curPos++\n          }\n        }\n        if (delEnd === this.valArray.length) {\n          // yay, you can delete everything without checking\n          for (var i = delEnd - 1, v = this.valArray[i]; i >= delStart; v = this.valArray[--i]) {\n            super.delete(i, 1)\n          }\n        } else {\n          if (typeof v === 'string') {\n            delEnd--\n          }\n          var rightSel = {}\n          for (var i = delEnd, v = this.valArray[i]; i >= delStart; v = this.valArray[--i]) {\n            if (v.constructor === Array) {\n              if (rightSel[v[0]] === undefined) {\n                if (v[1] === curSel[v[0]]) {\n                  // case 1.\n                  super.delete(i, 1)\n                }\n                rightSel[v[0]] = v[1]\n              } else {\n                // case 2.\n                super.delete(i, 1)\n              }\n            } else if (typeof v === 'string') {\n              // always delete the strings\n              super.delete(i, 1)\n            }\n          }\n        }\n      }\n      /*\n      1. get selection attributes from position $from\n         (name it antiAttrs, and we'll use it to make sure that selection ends in antiAttrs)\n      2. Insert selection $attr, if necessary\n      3. Between from and to, we'll delete all selections that do not match $attr.\n         Furthermore, we'll update antiAttrs, if necessary\n      4. In the end well insert a selection that makes sure that selection($to) ends in antiAttrs  \n      */\n      select (from, to, attrName, attrValue) {\n        if (from == null || to == null || attrName == null, attrValue === undefined) {\n          throw new Error(\"You must define four parameters\")\n        } else {\n          var step2i\n          var step2sel\n          var antiAttrs = [attrName, null]\n          var curPos = 0\n          var i = 0\n          // 1. compute antiAttrs\n          for (; i < this.valArray.length; i++) {\n            let v = this.valArray[i]\n            if (curPos === from) {\n              break\n            }\n            if (v.constructor === Array) {\n              if (v[0] === attrName) {\n                antiAttrs[1] = v[1]\n              }\n            } else if (typeof v === 'string') {\n              curPos++\n            }\n          }\n          // 2. Insert attr\n          if (antiAttrs[1] !== attrValue) {\n            // we'll execute this later\n            step2i = i\n            step2sel = [attrName, attrValue]\n          }\n           \n          // 3. update antiAttrs, modify selection\n          var deletes = []\n          for (; i < this.valArray.length; i++) {\n            let v = this.valArray[i]\n            if (curPos === to) {\n              break\n            }\n            if (v.constructor === Array) {\n              if (v[0] === attrName) {\n                antiAttrs[1] = v[1]\n                deletes.push(i)\n              }\n            } else if (typeof v === 'string') {\n              curPos++\n            }\n          }\n          // actually delete the found selections\n          // also.. we have to delete from right to left (so that the positions dont change)\n          for (var j = deletes.length - 1; j >= 0; j--) {\n            var del = deletes[j]\n            super.delete(del, 1)\n            // update i, rel. to \n            if (del < i) {\n              i--\n            }\n            if (del < step2i) {\n              step2i--\n            }\n          }\n          // 4. Update selection to match antiAttrs\n          // never insert, if not necessary \n          //  1. when it is the last position ~ i < valArray.length)\n          //  2. when a similar attrName already exists between i and the next character\n          if (antiAttrs[1] !== attrValue && i < this.valArray.length) { // check 1.\n            var performStep4 = true \n            var v\n            for (j = i, v = this.valArray[j]; j < this.valArray.length && v.constructor === Array; v = this.valArray[++j]) {\n              if (v[0] === attrName) {\n                performStep4 = false // check 2.\n                if (v[1] === attrValue) {\n                  super.delete(j, 1)\n                }\n                break\n              }\n            }\n            if (performStep4) {\n              var sel = [attrName, antiAttrs[1]]\n              super.insert(i, [sel])\n            }\n          }\n          if (step2i != null) {\n            super.insert(step2i, [step2sel])\n            // if there are some selections to the left of step2sel, delete them if possible\n            // * have same attribute name\n            // * no insert between step2sel and selection\n            for (j = step2i - 1, v = this.valArray[j]; j >= 0 && v.constructor === Array; v = this.valArray[--j] ) {\n              if (v[0] === attrName) {\n                super.delete(j, 1)\n              }\n            }\n          }\n        }\n      }\n      bind (quill) {\n        this.instances.push(quill)\n        var self = this\n        \n        // this function makes sure that either the\n        // quill event is executed, or the yjs observer is executed\n        var token = true\n        function mutualExcluse (f) {\n          if (token) {\n            token = false\n            try {\n              f()\n            } catch (e) {\n              token = true\n              throw new Error(e)\n            }\n            token = true\n          }\n        }\n        \n        quill.setContents(this.toOTOps())\n        \n        quill.on('text-change', function (delta) {\n          console.log(delta.ops, delta.ops[0], delta.ops[1] ? delta.ops[1].insert : null)\n          mutualExcluse(function () {\n            var pos = 0\n            for (var i = 0; i < delta.ops.length; i++) {\n              var op = delta.ops[i]\n              if (op.insert != null) {\n                var attrs = self.insert(pos, op.insert)\n                // create new selection\n                for (var name in op.attributes) {\n                  if (op.attributes[name] != attrs[name]) {\n                    self.select(pos, pos + op.insert.length, name, op.attributes[name])\n                  }\n                }\n                // not-existence of an attribute in op.attributes denotes\n                // that we have to unselect (set to null)\n                for (var name in attrs) {\n                  if (op.attributes == null || attrs[name] != op.attributes[name]) {\n                    self.select(pos, pos + op.insert.length, name, null)\n                  } \n                }\n                pos += op.insert.length\n              }\n              if (op.delete != null) {\n                self.delete(pos, op.delete)\n              }\n              if (op.retain != null) {\n                var afterRetain = pos + op.retain\n                if (afterRetain > self.length) {\n                  var diff = afterRetain - self.length\n                  var enters = ''\n                  while (diff !== 0) {\n                    diff--\n                    enters += '\\n'\n                  }\n                  for (var name in op.attributes) {\n                    quill.formatText(self.length, self.length + op.retain, name, null)\n                    // quill.deleteText(self.length, self.length + op.retain)\n                  }\n                  quill.insertText(self.length, enters, op.attributes)\n                  self.insert(self.length, enters)\n                }\n                for (var name in op.attributes) {\n                  self.select(pos, pos + op.retain, name, op.attributes[name])\n                }\n                pos = afterRetain\n              }\n            }\n          })\n        })\n        this.observe(function (events) {\n          mutualExcluse(function () {\n            for (var i=0; i < events.length; i++) {\n              var event = events[i]\n              if (event.type === 'insert') {\n                if (typeof event.value === 'string') {\n                  var position = 0\n                  var insertSel = {}\n                  for (var l = event.index - 1; l >= 0; l--) {\n                    var v = self.valArray[l]\n                    if (typeof v === 'string') {\n                      position++\n                    } else if (v.constructor === Array && typeof insertSel[v[0]] === 'undefined') {\n                      insertSel[v[0]] = v[1]\n                    }\n                  }\n                  quill.insertText(position, event.value, insertSel)\n                } else if (event.value.constructor === Array) {\n                  // a new selection is created\n                  // find left selection that matches newSel[0]\n                  var curSel = null\n                  var newSel = event.value\n                  // denotes the start position of the selection\n                  // (without the selection objects)\n                  var selectionStart = 0\n                  var v // helper variable\n                  for (var j = event.index - 1; j >= 0; j--) {\n                    v = self.valArray[j]\n                    if (v.constructor === Array) {\n                      // check if v matches newSel\n                      if (newSel[0] === v[0]) {\n                        // found a selection\n                        // update curSel and go to next step\n                        curSel = v[1]\n                        break\n                      }\n                    } else if (typeof v === 'string') {\n                      selectionStart++\n                    }\n                  }\n                  // make sure to decrement j, so we correctly compute selectionStart\n                  for (; j >= 0; j--) {\n                    v = self.valArray[j]\n                    if (typeof v === 'string') {\n                      selectionStart++\n                    }\n                  }\n                  // either a selection was found {then curSel was updated}, or not (then curSel = null)\n                  if (newSel[1] === curSel) {\n                    // both are the same. not necessary to do anything\n                    return\n                  }\n                  // now find out the range over which newSel has to be created\n                  var selectionEnd = selectionStart\n                  for (var k = event.index + 1; k < self.valArray.length; k++) {\n                    v = self.valArray[k]\n                    if (v.constructor === Array) {\n                      if (v[0] === newSel[0]) {\n                        // found another selection with same attr name\n                        break\n                      }\n                    } else if (typeof v === 'string') {\n                      selectionEnd++\n                    }\n                  }\n                  // create a selection from selectionStart to selectionEnd\n                  if (selectionStart !== selectionEnd) {\n                    quill.formatText(selectionStart, selectionEnd, newSel[0], newSel[1])\n                  }\n                }\n              } else if (event.type === 'delete') {\n                if (typeof event.value === 'string') { // TODO: see button. add  || `event.length > 1`\n                  // only if these conditions are true, we have to actually check if we have to delete sth.\n                  // Then we have to check if between pos and pos + event.length are selections:\n                  // delete till pos + (event.length - number of selections)\n                  var pos = 0\n                  for (var u = 0; u < event.index; u++) {\n                    var v = self.valArray[u]\n                    if (typeof v === 'string') {\n                      pos++\n                    }\n                  }\n                  var delLength = event.length\n                  /* TODO!!\n                  they do not exist anymore.. so i can't query. you have to query over event.value(s) - but that not yet implemented\n                  for (; i < event.index + event.length; i++) {\n                    if (self.valArray[i].constructor === Array) {\n                      delLength--\n                    }\n                  }*/\n                  quill.deleteText(pos, pos + delLength)\n                } else if (event.value.constructor === Array) {\n                  var curSel = null\n                  var from = 0\n                  for (var x = event.index - 1; x >= 0; x--) {\n                    var v = self.valArray[x]\n                    if (v.constructor === Array) {\n                      if (v[0] === event.value[0]) {\n                        curSel = v[1]\n                        break\n                      }\n                    } else if (typeof v === 'string') {\n                      from++\n                    }\n                  }\n                  for (; x >= 0; v = self.valArray[--x]) {\n                    if (typeof v === 'string') {\n                      from++\n                    }\n                  }\n                  var to = from\n                  for (var x = event.index; x < self.valArray.length; x++) {\n                    var v = self.valArray[x]\n                    if (v.constructor === Array) {\n                      if (v[0] === event.value[0]) {\n                        break\n                      }\n                    } else if (typeof v === 'string') {\n                      to++\n                    }\n                  }\n                  if (curSel !== event.value[1] && from !== to) {\n                    quill.formatText(from, to, event.value[0], curSel)\n                  }\n                }\n              }\n            }\n            quill.editor.checkUpdate()\n          })\n        })\n      }\n      * _changed () {\n        this.instances.forEach(function (quill) {\n          quill.editor.checkUpdate()\n        })\n        yield* Y.Array.class.prototype._changed.apply(this, arguments)\n      }\n    }\n    Y.extend('Richtext', new Y.utils.CustomType({\n      name: 'Richtext',\n      class: YRichtext,\n      struct: 'List',\n      initType: function * YTextInitializer (os, model) {\n        var valArray = []\n        var idArray = yield* Y.Struct.List.map.call(this, model, function (c) {\n          valArray.push(c.content)\n          return JSON.stringify(c.id)\n        })\n        return new YRichtext(os, model.id, idArray, valArray)\n      }\n    }))\n  })\n}\n\nmodule.exports = extend\nif (typeof Y !== 'undefined') {\n  extend(Y)\n}\n","(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){\n/* global Y */\n'use strict';\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if (\"value\" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nfunction extend(Y) {\n  Y.requestModules(['Array']).then(function () {\n    var YRichtext = function (_Y$Array$class) {\n      _inherits(YRichtext, _Y$Array$class);\n\n      function YRichtext(os, _model, idArray, valArray) {\n        _classCallCheck(this, YRichtext);\n\n        var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(YRichtext).call(this, os, _model, idArray, valArray));\n\n        _this._length = 0;\n        _this.instances = [];\n        for (var i = 0, v = valArray[i]; i < valArray.length; i++) {\n          if (typeof v === 'string') {\n            _this._length++;\n          }\n        }\n        var self = _this;\n        _this.observe(function (events) {\n          for (var i = 0, event = events[i]; i < events.length; i++) {\n            if (event.type === 'insert') {\n              if (typeof event.value === 'string') {\n                self._length++;\n              }\n            } else if (event.type === 'delete') {\n              if (typeof event.value === 'string') {\n                self._length--;\n              }\n            }\n          }\n        });\n        return _this;\n      }\n\n      _createClass(YRichtext, [{\n        key: 'toString',\n        value: function toString() {\n          return this.valArray.map(function (v) {\n            if (typeof v === 'string') {\n              return v;\n            }\n          }).join('');\n        }\n      }, {\n        key: 'toOTOps',\n        value: function toOTOps() {\n          var ops = [];\n          var op = {\n            insert: [],\n            attributes: {}\n          };\n          function createNewOp() {\n            var attrs = {};\n            // copy attributes\n            for (var name in op.attributes) {\n              attrs[name] = op.attributes[name];\n            }\n            op = {\n              insert: [],\n              attributes: attrs\n            };\n          }\n          var i = 0;\n          for (; i < this.valArray.length; i++) {\n            var v = this.valArray[i];\n            if (v.constructor === Array) {\n              if (op.insert.length > 0) {\n                op.insert = op.insert.join('');\n                ops.push(op);\n                createNewOp();\n              }\n              if (v[1] === null) {\n                delete op.attributes[v[0]];\n              } else {\n                op.attributes[v[0]] = v[1];\n              }\n            } else {\n              op.insert.push(v);\n            }\n          }\n          if (op.insert.length > 0) {\n            op.insert = op.insert.join('');\n            ops.push(op);\n          }\n          return ops;\n        }\n      }, {\n        key: 'insert',\n        value: function insert(pos, content) {\n          var curPos = 0;\n          var selection = {};\n          for (var i = 0; i < this.valArray.length; i++) {\n            if (curPos === pos) {\n              break;\n            }\n            var v = this.valArray[i];\n            if (typeof v === 'string') {\n              curPos++;\n            } else if (v.constructor === Array) {\n              if (v[1] === null) {\n                delete selection[v[0]];\n              } else {\n                selection[v[0]] = v[1];\n              }\n            }\n          }\n          _get(Object.getPrototypeOf(YRichtext.prototype), 'insert', this).call(this, i, content.split(''));\n          return selection;\n        }\n      }, {\n        key: 'delete',\n        value: function _delete(pos, length) {\n          /*\n            let x = to be deleted string\n            let s = some string\n            let * = some selection\n            E.g.\n            sss*s***x*xxxxx***xx*x**ss*s\n                 |---delete-range--|\n               delStart         delEnd\n            \n            We'll check the following\n            * is it possible to delete some of the selections?\n              1. a dominating selection to the right could be the same as the selection (curSel) to delStart\n              2. a selections could be overwritten by another selection to the right \n          */\n          var curPos = 0;\n          var curSel = {};\n          var endPos = pos + length;\n          if (length <= 0) return;\n          var delStart; // relative to valArray\n          var delEnd; // ..\n          var v; // helper variable for elements of valArray\n\n          for (delStart = 0, v = this.valArray[delStart]; curPos < pos && delStart < this.valArray.length; v = this.valArray[++delStart]) {\n            if (typeof v === 'string') {\n              curPos++;\n            } else if (v.constructor === Array) {\n              curSel[v[0]] = v[1];\n            }\n          }\n          for (delEnd = delStart, v = this.valArray[delEnd]; curPos < endPos && delEnd < this.valArray.length; v = this.valArray[++delEnd]) {\n            if (typeof v === 'string') {\n              curPos++;\n            }\n          }\n          if (delEnd === this.valArray.length) {\n            // yay, you can delete everything without checking\n            for (var i = delEnd - 1, v = this.valArray[i]; i >= delStart; v = this.valArray[--i]) {\n              _get(Object.getPrototypeOf(YRichtext.prototype), 'delete', this).call(this, i, 1);\n            }\n          } else {\n            if (typeof v === 'string') {\n              delEnd--;\n            }\n            var rightSel = {};\n            for (var i = delEnd, v = this.valArray[i]; i >= delStart; v = this.valArray[--i]) {\n              if (v.constructor === Array) {\n                if (rightSel[v[0]] === undefined) {\n                  if (v[1] === curSel[v[0]]) {\n                    // case 1.\n                    _get(Object.getPrototypeOf(YRichtext.prototype), 'delete', this).call(this, i, 1);\n                  }\n                  rightSel[v[0]] = v[1];\n                } else {\n                  // case 2.\n                  _get(Object.getPrototypeOf(YRichtext.prototype), 'delete', this).call(this, i, 1);\n                }\n              } else if (typeof v === 'string') {\n                // always delete the strings\n                _get(Object.getPrototypeOf(YRichtext.prototype), 'delete', this).call(this, i, 1);\n              }\n            }\n          }\n        }\n        /*\n        1. get selection attributes from position $from\n           (name it antiAttrs, and we'll use it to make sure that selection ends in antiAttrs)\n        2. Insert selection $attr, if necessary\n        3. Between from and to, we'll delete all selections that do not match $attr.\n           Furthermore, we'll update antiAttrs, if necessary\n        4. In the end well insert a selection that makes sure that selection($to) ends in antiAttrs  \n        */\n\n      }, {\n        key: 'select',\n        value: function select(from, to, attrName, attrValue) {\n          if (from == null || to == null || attrName == null, attrValue === undefined) {\n            throw new Error(\"You must define four parameters\");\n          } else {\n            var step2i;\n            var step2sel;\n            var antiAttrs = [attrName, null];\n            var curPos = 0;\n            var i = 0;\n            // 1. compute antiAttrs\n            for (; i < this.valArray.length; i++) {\n              var _v = this.valArray[i];\n              if (curPos === from) {\n                break;\n              }\n              if (_v.constructor === Array) {\n                if (_v[0] === attrName) {\n                  antiAttrs[1] = _v[1];\n                }\n              } else if (typeof _v === 'string') {\n                curPos++;\n              }\n            }\n            // 2. Insert attr\n            if (antiAttrs[1] !== attrValue) {\n              // we'll execute this later\n              step2i = i;\n              step2sel = [attrName, attrValue];\n            }\n\n            // 3. update antiAttrs, modify selection\n            var deletes = [];\n            for (; i < this.valArray.length; i++) {\n              var _v2 = this.valArray[i];\n              if (curPos === to) {\n                break;\n              }\n              if (_v2.constructor === Array) {\n                if (_v2[0] === attrName) {\n                  antiAttrs[1] = _v2[1];\n                  deletes.push(i);\n                }\n              } else if (typeof _v2 === 'string') {\n                curPos++;\n              }\n            }\n            // actually delete the found selections\n            // also.. we have to delete from right to left (so that the positions dont change)\n            for (var j = deletes.length - 1; j >= 0; j--) {\n              var del = deletes[j];\n              _get(Object.getPrototypeOf(YRichtext.prototype), 'delete', this).call(this, del, 1);\n              // update i, rel. to\n              if (del < i) {\n                i--;\n              }\n              if (del < step2i) {\n                step2i--;\n              }\n            }\n            // 4. Update selection to match antiAttrs\n            // never insert, if not necessary\n            //  1. when it is the last position ~ i < valArray.length)\n            //  2. when a similar attrName already exists between i and the next character\n            if (antiAttrs[1] !== attrValue && i < this.valArray.length) {\n              // check 1.\n              var performStep4 = true;\n              var v;\n              for (j = i, v = this.valArray[j]; j < this.valArray.length && v.constructor === Array; v = this.valArray[++j]) {\n                if (v[0] === attrName) {\n                  performStep4 = false; // check 2.\n                  if (v[1] === attrValue) {\n                    _get(Object.getPrototypeOf(YRichtext.prototype), 'delete', this).call(this, j, 1);\n                  }\n                  break;\n                }\n              }\n              if (performStep4) {\n                var sel = [attrName, antiAttrs[1]];\n                _get(Object.getPrototypeOf(YRichtext.prototype), 'insert', this).call(this, i, [sel]);\n              }\n            }\n            if (step2i != null) {\n              _get(Object.getPrototypeOf(YRichtext.prototype), 'insert', this).call(this, step2i, [step2sel]);\n              // if there are some selections to the left of step2sel, delete them if possible\n              // * have same attribute name\n              // * no insert between step2sel and selection\n              for (j = step2i - 1, v = this.valArray[j]; j >= 0 && v.constructor === Array; v = this.valArray[--j]) {\n                if (v[0] === attrName) {\n                  _get(Object.getPrototypeOf(YRichtext.prototype), 'delete', this).call(this, j, 1);\n                }\n              }\n            }\n          }\n        }\n      }, {\n        key: 'bind',\n        value: function bind(quill) {\n          this.instances.push(quill);\n          var self = this;\n\n          // this function makes sure that either the\n          // quill event is executed, or the yjs observer is executed\n          var token = true;\n          function mutualExcluse(f) {\n            if (token) {\n              token = false;\n              try {\n                f();\n              } catch (e) {\n                token = true;\n                throw new Error(e);\n              }\n              token = true;\n            }\n          }\n\n          quill.setContents(this.toOTOps());\n\n          quill.on('text-change', function (delta) {\n            console.log(delta.ops, delta.ops[0], delta.ops[1] ? delta.ops[1].insert : null);\n            mutualExcluse(function () {\n              var pos = 0;\n              for (var i = 0; i < delta.ops.length; i++) {\n                var op = delta.ops[i];\n                if (op.insert != null) {\n                  var attrs = self.insert(pos, op.insert);\n                  // create new selection\n                  for (var name in op.attributes) {\n                    if (op.attributes[name] != attrs[name]) {\n                      self.select(pos, pos + op.insert.length, name, op.attributes[name]);\n                    }\n                  }\n                  // not-existence of an attribute in op.attributes denotes\n                  // that we have to unselect (set to null)\n                  for (var name in attrs) {\n                    if (op.attributes == null || attrs[name] != op.attributes[name]) {\n                      self.select(pos, pos + op.insert.length, name, null);\n                    }\n                  }\n                  pos += op.insert.length;\n                }\n                if (op.delete != null) {\n                  self.delete(pos, op.delete);\n                }\n                if (op.retain != null) {\n                  var afterRetain = pos + op.retain;\n                  if (afterRetain > self.length) {\n                    var diff = afterRetain - self.length;\n                    var enters = '';\n                    while (diff !== 0) {\n                      diff--;\n                      enters += '\\n';\n                    }\n                    for (var name in op.attributes) {\n                      quill.formatText(self.length, self.length + op.retain, name, null);\n                      // quill.deleteText(self.length, self.length + op.retain)\n                    }\n                    quill.insertText(self.length, enters, op.attributes);\n                    self.insert(self.length, enters);\n                  }\n                  for (var name in op.attributes) {\n                    self.select(pos, pos + op.retain, name, op.attributes[name]);\n                  }\n                  pos = afterRetain;\n                }\n              }\n            });\n          });\n          this.observe(function (events) {\n            mutualExcluse(function () {\n              for (var i = 0; i < events.length; i++) {\n                var event = events[i];\n                if (event.type === 'insert') {\n                  if (typeof event.value === 'string') {\n                    var position = 0;\n                    var insertSel = {};\n                    for (var l = event.index - 1; l >= 0; l--) {\n                      var v = self.valArray[l];\n                      if (typeof v === 'string') {\n                        position++;\n                      } else if (v.constructor === Array && typeof insertSel[v[0]] === 'undefined') {\n                        insertSel[v[0]] = v[1];\n                      }\n                    }\n                    quill.insertText(position, event.value, insertSel);\n                  } else if (event.value.constructor === Array) {\n                    // a new selection is created\n                    // find left selection that matches newSel[0]\n                    var curSel = null;\n                    var newSel = event.value;\n                    // denotes the start position of the selection\n                    // (without the selection objects)\n                    var selectionStart = 0;\n                    var v; // helper variable\n                    for (var j = event.index - 1; j >= 0; j--) {\n                      v = self.valArray[j];\n                      if (v.constructor === Array) {\n                        // check if v matches newSel\n                        if (newSel[0] === v[0]) {\n                          // found a selection\n                          // update curSel and go to next step\n                          curSel = v[1];\n                          break;\n                        }\n                      } else if (typeof v === 'string') {\n                        selectionStart++;\n                      }\n                    }\n                    // make sure to decrement j, so we correctly compute selectionStart\n                    for (; j >= 0; j--) {\n                      v = self.valArray[j];\n                      if (typeof v === 'string') {\n                        selectionStart++;\n                      }\n                    }\n                    // either a selection was found {then curSel was updated}, or not (then curSel = null)\n                    if (newSel[1] === curSel) {\n                      // both are the same. not necessary to do anything\n                      return;\n                    }\n                    // now find out the range over which newSel has to be created\n                    var selectionEnd = selectionStart;\n                    for (var k = event.index + 1; k < self.valArray.length; k++) {\n                      v = self.valArray[k];\n                      if (v.constructor === Array) {\n                        if (v[0] === newSel[0]) {\n                          // found another selection with same attr name\n                          break;\n                        }\n                      } else if (typeof v === 'string') {\n                        selectionEnd++;\n                      }\n                    }\n                    // create a selection from selectionStart to selectionEnd\n                    if (selectionStart !== selectionEnd) {\n                      quill.formatText(selectionStart, selectionEnd, newSel[0], newSel[1]);\n                    }\n                  }\n                } else if (event.type === 'delete') {\n                  if (typeof event.value === 'string') {\n                    // TODO: see button. add  || `event.length > 1`\n                    // only if these conditions are true, we have to actually check if we have to delete sth.\n                    // Then we have to check if between pos and pos + event.length are selections:\n                    // delete till pos + (event.length - number of selections)\n                    var pos = 0;\n                    for (var u = 0; u < event.index; u++) {\n                      var v = self.valArray[u];\n                      if (typeof v === 'string') {\n                        pos++;\n                      }\n                    }\n                    var delLength = event.length;\n                    /* TODO!!\n                    they do not exist anymore.. so i can't query. you have to query over event.value(s) - but that not yet implemented\n                    for (; i < event.index + event.length; i++) {\n                      if (self.valArray[i].constructor === Array) {\n                        delLength--\n                      }\n                    }*/\n                    quill.deleteText(pos, pos + delLength);\n                  } else if (event.value.constructor === Array) {\n                    var curSel = null;\n                    var from = 0;\n                    for (var x = event.index - 1; x >= 0; x--) {\n                      var v = self.valArray[x];\n                      if (v.constructor === Array) {\n                        if (v[0] === event.value[0]) {\n                          curSel = v[1];\n                          break;\n                        }\n                      } else if (typeof v === 'string') {\n                        from++;\n                      }\n                    }\n                    for (; x >= 0; v = self.valArray[--x]) {\n                      if (typeof v === 'string') {\n                        from++;\n                      }\n                    }\n                    var to = from;\n                    for (var x = event.index; x < self.valArray.length; x++) {\n                      var v = self.valArray[x];\n                      if (v.constructor === Array) {\n                        if (v[0] === event.value[0]) {\n                          break;\n                        }\n                      } else if (typeof v === 'string') {\n                        to++;\n                      }\n                    }\n                    if (curSel !== event.value[1] && from !== to) {\n                      quill.formatText(from, to, event.value[0], curSel);\n                    }\n                  }\n                }\n              }\n              quill.editor.checkUpdate();\n            });\n          });\n        }\n      }, {\n        key: '_changed',\n        value: regeneratorRuntime.mark(function _changed() {\n          var _args = arguments;\n          return regeneratorRuntime.wrap(function _changed$(_context) {\n            while (1) {\n              switch (_context.prev = _context.next) {\n                case 0:\n                  this.instances.forEach(function (quill) {\n                    quill.editor.checkUpdate();\n                  });\n                  return _context.delegateYield(Y.Array.class.prototype._changed.apply(this, _args), 't0', 2);\n\n                case 2:\n                case 'end':\n                  return _context.stop();\n              }\n            }\n          }, _changed, this);\n        })\n      }, {\n        key: 'length',\n        get: function get() {\n          return this._length;\n        }\n      }]);\n\n      return YRichtext;\n    }(Y.Array['class']);\n\n    Y.extend('Richtext', new Y.utils.CustomType({\n      name: 'Richtext',\n      class: YRichtext,\n      struct: 'List',\n      initType: regeneratorRuntime.mark(function YTextInitializer(os, model) {\n        var valArray, idArray;\n        return regeneratorRuntime.wrap(function YTextInitializer$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                valArray = [];\n                return _context2.delegateYield(Y.Struct.List.map.call(this, model, function (c) {\n                  valArray.push(c.content);\n                  return JSON.stringify(c.id);\n                }), 't0', 2);\n\n              case 2:\n                idArray = _context2.t0;\n                return _context2.abrupt('return', new YRichtext(os, model.id, idArray, valArray));\n\n              case 4:\n              case 'end':\n                return _context2.stop();\n            }\n          }\n        }, YTextInitializer, this);\n      })\n    }));\n  });\n}\n\nmodule.exports = extend;\nif (typeof Y !== 'undefined') {\n  extend(Y);\n}\n\n},{}]},{},[1])\n\n"],"sourceRoot":"/source/"}