{"version":3,"sources":["Types/BasicTypes.coffee"],"names":[],"mappings":"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","file":"Types/BasicTypes.js","sourceRoot":"/source/","sourcesContent":["module.exports = (HB)->\n  # @see Engine.parse\n  parser = {}\n  execution_listener = []\n\n  #\n  # @private\n  # @abstract\n  # @nodoc\n  # A generic interface to operations.\n  #\n  # An operation has the following methods:\n  # * _encode: encodes an operation (needed only if instance of this operation is sent).\n  # * execute: execute the effects of this operations. Good examples are Insert-type and AddName-type\n  # * val: in the case that the operation holds a value\n  #\n  # Furthermore an encodable operation has a parser. We extend the parser object in order to parse encoded operations.\n  #\n  class Operation\n\n    #\n    # @param {Object} uid A unique identifier.\n    # If uid is undefined, a new uid will be created before at the end of the execution sequence\n    #\n    constructor: (uid)->\n      @is_deleted = false\n      @garbage_collected = false\n      @event_listeners = [] # TODO: rename to observers or sth like that\n      if uid?\n        @uid = uid\n\n    type: \"Insert\"\n\n    #\n    # Add an event listener. It depends on the operation which events are supported.\n    # @param {Function} f f is executed in case the event fires.\n    #\n    observe: (f)->\n      @event_listeners.push f\n\n    #\n    # Deletes function from the observer list\n    # @see Operation.observe\n    #\n    # @overload unobserve(event, f)\n    #   @param f     {Function} The function that you want to delete \n    unobserve: (f)->\n      @event_listeners = @event_listeners.filter (g)->\n        f isnt g\n\n    #\n    # Deletes all subscribed event listeners.\n    # This should be called, e.g. after this has been replaced.\n    # (Then only one replace event should fire. )\n    # This is also called in the cleanup method.\n    deleteAllObservers: ()->\n      @event_listeners = []\n\n    #\n    # Fire an event.\n    # TODO: Do something with timeouts. You don't want this to fire for every operation (e.g. insert).\n    # TODO: do you need callEvent+forwardEvent? Only one suffices probably\n    callEvent: ()->\n      @forwardEvent @, arguments...\n\n    #\n    # Fire an event and specify in which context the listener is called (set 'this').\n    # TODO: do you need this ?\n    forwardEvent: (op, args...)->\n      for f in @event_listeners\n        f.call op, args...\n\n    isDeleted: ()->\n      @is_deleted\n\n    applyDelete: (garbagecollect = true)->\n      if not @garbage_collected\n        #console.log \"applyDelete: #{@type}\"\n        @is_deleted = true\n        if garbagecollect\n          @garbage_collected = true\n          HB.addToGarbageCollector @\n\n    cleanup: ()->\n      #console.log \"cleanup: #{@type}\"\n      HB.removeOperation @\n      @deleteAllObservers()\n\n    #\n    # Set the parent of this operation.\n    #\n    setParent: (@parent)->\n\n    #\n    # Get the parent of this operation.\n    #\n    getParent: ()->\n      @parent\n\n    #\n    # Computes a unique identifier (uid) that identifies this operation.\n    #\n    getUid: ()->\n      @uid\n\n    dontSync: ()->\n      @uid.doSync = false\n\n    #\n    # @private\n    # If not already done, set the uid\n    # Add this to the HB\n    # Notify the all the listeners.\n    #\n    execute: ()->\n      @is_executed = true\n      if not @uid?\n        # When this operation was created without a uid, then set it here.\n        # There is only one other place, where this can be done - before an Insertion\n        # is executed (because we need the creator_id)\n        @uid = HB.getNextOperationIdentifier()\n      HB.addOperation @\n      for l in execution_listener\n        l @_encode()\n      @\n\n    #\n    # @private\n    # Operations may depend on other operations (linked lists, etc.).\n    # The saveOperation and validateSavedOperations methods provide\n    # an easy way to refer to these operations via an uid or object reference.\n    #\n    # For example: We can create a new Delete operation that deletes the operation $o like this\n    #     - var d = new Delete(uid, $o);   or\n    #     - var d = new Delete(uid, $o.getUid());\n    # Either way we want to access $o via d.deletes. In the second case validateSavedOperations must be called first.\n    #\n    # @overload saveOperation(name, op_uid)\n    #   @param {String} name The name of the operation. After validating (with validateSavedOperations) the instantiated operation will be accessible via this[name].\n    #   @param {Object} op_uid A uid that refers to an operation\n    # @overload saveOperation(name, op)\n    #   @param {String} name The name of the operation. After calling this function op is accessible via this[name].\n    #   @param {Operation} op An Operation object\n    #\n    saveOperation: (name, op)->\n\n      #\n      # Every instance of $Operation must have an $execute function.\n      # We use duck-typing to check if op is instantiated since there\n      # could exist multiple classes of $Operation\n      #\n      if op?.execute?\n        # is instantiated\n        @[name] = op\n      else if op?\n        # not initialized. Do it when calling $validateSavedOperations()\n        @unchecked ?= {}\n        @unchecked[name] = op\n\n    #\n    # @private\n    # After calling this function all not instantiated operations will be accessible.\n    # @see Operation.saveOperation\n    #\n    # @return [Boolean] Whether it was possible to instantiate all operations.\n    #\n    validateSavedOperations: ()->\n      uninstantiated = {}\n      success = @\n      for name, op_uid of @unchecked\n        op = HB.getOperation op_uid\n        if op\n          @[name] = op\n        else\n          uninstantiated[name] = op_uid\n          success = false\n      delete @unchecked\n      if not success\n        @unchecked = uninstantiated\n      success\n\n\n\n  #\n  # @nodoc\n  # A simple Delete-type operation that deletes an operation.\n  #\n  class Delete extends Operation\n\n    #\n    # @param {Object} uid A unique identifier. If uid is undefined, a new uid will be created.\n    # @param {Object} deletes UID or reference of the operation that this to be deleted.\n    #\n    constructor: (uid, deletes)->\n      @saveOperation 'deletes', deletes\n      super uid\n\n    type: \"Delete\"\n\n    #\n    # @private\n    # Convert all relevant information of this operation to the json-format.\n    # This result can be sent to other clients.\n    #\n    _encode: ()->\n      {\n        'type': \"Delete\"\n        'uid': @getUid()\n        'deletes': @deletes.getUid()\n      }\n\n    #\n    # @private\n    # Apply the deletion.\n    #\n    execute: ()->\n      if @validateSavedOperations()\n        res = super\n        if res\n          @deletes.applyDelete @\n        res\n      else\n        false\n\n  #\n  # Define how to parse Delete operations.\n  #\n  parser['Delete'] = (o)->\n    {\n      'uid' : uid\n      'deletes': deletes_uid\n    } = o\n    new Delete uid, deletes_uid\n\n  #\n  # @nodoc\n  # A simple insert-type operation.\n  #\n  # An insert operation is always positioned between two other insert operations.\n  # Internally this is realized as associative lists, whereby each insert operation has a predecessor and a successor.\n  # For the sake of efficiency we maintain two lists:\n  #   - The short-list (abbrev. sl) maintains only the operations that are not deleted\n  #   - The complete-list (abbrev. cl) maintains all operations\n  #\n  class Insert extends Operation\n\n    #\n    # @param {Object} uid A unique identifier. If uid is undefined, a new uid will be created.\n    # @param {Operation} prev_cl The predecessor of this operation in the complete-list (cl)\n    # @param {Operation} next_cl The successor of this operation in the complete-list (cl)\n    #\n    constructor: (uid, prev_cl, next_cl, origin)->\n      @saveOperation 'prev_cl', prev_cl\n      @saveOperation 'next_cl', next_cl\n      if origin?\n        @saveOperation 'origin', origin\n      else\n        @saveOperation 'origin', prev_cl\n      super uid\n\n    type: \"Insert\"\n\n    #\n    # set content to null and other stuff\n    # @private\n    #\n    applyDelete: (o)->\n      @deleted_by ?= []\n      callLater = false\n      if @parent? and not @isDeleted() and o? # o? : if not o?, then the delimiter deleted this Insertion. Furthermore, it would be wrong to call it. TODO: make this more expressive and save\n        # call iff wasn't deleted earlyer\n        callLater = true\n      if o?\n        @deleted_by.push o\n      garbagecollect = false\n      if not (@prev_cl? and @next_cl?) or @prev_cl.isDeleted()\n        garbagecollect = true\n      super garbagecollect\n      if callLater\n        @callOperationSpecificDeleteEvents(o)\n      if @next_cl?.isDeleted()\n        # garbage collect next_cl\n        @next_cl.applyDelete()\n\n    cleanup: ()->\n      # TODO: Debugging\n      if @prev_cl?.isDeleted()\n        # delete all ops that delete this insertion\n        for d in @deleted_by\n          d.cleanup()\n\n        # throw new Error \"left is not deleted. inconsistency!, wrararar\"\n        # delete origin references to the right\n        o = @next_cl\n        while o.type isnt \"Delimiter\"\n          if o.origin is @\n            o.origin = @prev_cl\n          o = o.next_cl\n        # reconnect left/right\n        @prev_cl.next_cl = @next_cl\n        @next_cl.prev_cl = @prev_cl\n        super\n\n\n    #\n    # @private\n    # The amount of positions that $this operation was moved to the right.\n    #\n    getDistanceToOrigin: ()->\n      d = 0\n      o = @prev_cl\n      while true\n        if @origin is o\n          break\n        d++\n        o = o.prev_cl\n      d\n\n    #\n    # @private\n    # Include this operation in the associative lists.\n    execute: ()->\n      if not @validateSavedOperations()\n        return false\n      else\n        if @prev_cl?\n          distance_to_origin = @getDistanceToOrigin() # most cases: 0\n          o = @prev_cl.next_cl\n          i = distance_to_origin # loop counter\n\n          # $this has to find a unique position between origin and the next known character\n          # case 1: $origin equals $o.origin: the $creator parameter decides if left or right\n          #         let $OL= [o1,o2,o3,o4], whereby $this is to be inserted between o1 and o4\n          #         o2,o3 and o4 origin is 1 (the position of o2)\n          #         there is the case that $this.creator < o2.creator, but o3.creator < $this.creator\n          #         then o2 knows o3. Since on another client $OL could be [o1,o3,o4] the problem is complex\n          #         therefore $this would be always to the right of o3\n          # case 2: $origin < $o.origin\n          #         if current $this insert_position > $o origin: $this ins\n          #         else $insert_position will not change\n          #         (maybe we encounter case 1 later, then this will be to the right of $o)\n          # case 3: $origin > $o.origin\n          #         $this insert_position is to the left of $o (forever!)\n          while true\n            if o isnt @next_cl\n              # $o happened concurrently\n              if o.getDistanceToOrigin() is i\n                # case 1\n                if o.uid.creator < @uid.creator\n                  @prev_cl = o\n                  distance_to_origin = i + 1\n                else\n                  # nop\n              else if o.getDistanceToOrigin() < i\n                # case 2\n                if i - distance_to_origin <= o.getDistanceToOrigin()\n                  @prev_cl = o\n                  distance_to_origin = i + 1\n                else\n                  #nop\n              else\n                # case 3\n                break\n              i++\n              o = o.next_cl\n            else\n              # $this knows that $o exists,\n              break\n          # now reconnect everything\n          @next_cl = @prev_cl.next_cl\n          @prev_cl.next_cl = @\n          @next_cl.prev_cl = @\n\n        @setParent @prev_cl.getParent() # do Insertions always have a parent?\n        super # notify the execution_listeners\n        @callOperationSpecificInsertEvents()\n        @\n\n    callOperationSpecificInsertEvents: ()->\n      @parent?.callEvent [\n        type: \"insert\"\n        position: @getPosition()\n        object: @parent\n        changedBy: @uid.creator\n        value: @content\n      ]\n\n    callOperationSpecificDeleteEvents: (o)->\n      @parent.callEvent [\n        type: \"delete\"\n        position: @getPosition()\n        object: @parent # TODO: You can combine getPosition + getParent in a more efficient manner! (only left Delimiter will hold @parent)\n        length: 1\n        changedBy: o.uid.creator\n      ]\n\n    #\n    # Compute the position of this operation.\n    #\n    getPosition: ()->\n      position = 0\n      prev = @prev_cl\n      while true\n        if prev instanceof Delimiter\n          break\n        if not prev.isDeleted()\n          position++\n        prev = prev.prev_cl\n      position\n\n  #\n  # @nodoc\n  # Defines an object that is cannot be changed. You can use this to set an immutable string, or a number.\n  #\n  class ImmutableObject extends Operation\n\n    #\n    # @param {Object} uid A unique identifier. If uid is undefined, a new uid will be created.\n    # @param {Object} content\n    #\n    constructor: (uid, @content, prev, next, origin)->\n      super uid, prev, next, origin\n\n    type: \"ImmutableObject\"\n\n    #\n    # @return [String] The content of this operation.\n    #\n    val : ()->\n      @content\n\n    #\n    # Encode this operation in such a way that it can be parsed by remote peers.\n    #\n    _encode: ()->\n      json = {\n        'type': \"ImmutableObject\"\n        'uid' : @getUid()\n        'content' : @content\n      }\n      if @prev_cl?\n        json['prev'] = @prev_cl.getUid()\n      if @next_cl?\n        json['next'] = @next_cl.getUid()\n      if @origin? # and @origin isnt @prev_cl\n        json[\"origin\"] = @origin().getUid()\n      json\n\n  parser['ImmutableObject'] = (json)->\n    {\n      'uid' : uid\n      'content' : content\n      'prev': prev\n      'next': next\n      'origin' : origin\n    } = json\n    new ImmutableObject uid, content, prev, next, origin\n\n  #\n  # @nodoc\n  # A delimiter is placed at the end and at the beginning of the associative lists.\n  # This is necessary in order to have a beginning and an end even if the content\n  # of the Engine is empty.\n  #\n  class Delimiter extends Operation\n    #\n    # @param {Object} uid A unique identifier. If uid is undefined, a new uid will be created.\n    # @param {Operation} prev_cl The predecessor of this operation in the complete-list (cl)\n    # @param {Operation} next_cl The successor of this operation in the complete-list (cl)\n    #\n    constructor: (uid, prev_cl, next_cl, origin)->\n      @saveOperation 'prev_cl', prev_cl\n      @saveOperation 'next_cl', next_cl\n      @saveOperation 'origin', prev_cl\n      super uid\n\n    type: \"Delimiter\"\n\n    applyDelete: ()->\n      super()\n      o = @next_cl\n      while o?\n        o.applyDelete()\n        o = o.next_cl\n      undefined\n\n    cleanup: ()->\n      super()\n\n    #\n    # @private\n    #\n    execute: ()->\n      if @unchecked?['next_cl']?\n        super\n      else if @unchecked?['prev_cl']\n        if @validateSavedOperations()\n          if @prev_cl.next_cl?\n            throw new Error \"Probably duplicated operations\"\n          @prev_cl.next_cl = @\n          super\n        else\n          false\n      else if @prev_cl? and not @prev_cl.next_cl?\n        delete @prev_cl.unchecked.next_cl\n        @prev_cl.next_cl = @\n        super\n      else if @prev_cl? or @next_cl? or true # TODO: are you sure? This can happen right?\n        super\n      #else\n      #  throw new Error \"Delimiter is unsufficient defined!\"\n\n    #\n    # @private\n    #\n    _encode: ()->\n      {\n        'type' : \"Delimiter\"\n        'uid' : @getUid()\n        'prev' : @prev_cl?.getUid()\n        'next' : @next_cl?.getUid()\n      }\n\n  parser['Delimiter'] = (json)->\n    {\n    'uid' : uid\n    'prev' : prev\n    'next' : next\n    } = json\n    new Delimiter uid, prev, next\n\n  # This is what this module exports after initializing it with the HistoryBuffer\n  {\n    'types' :\n      'Delete' : Delete\n      'Insert' : Insert\n      'Delimiter': Delimiter\n      'Operation': Operation\n      'ImmutableObject' : ImmutableObject\n    'parser' : parser\n    'execution_listener' : execution_listener\n  }\n\n\n\n\n"]}